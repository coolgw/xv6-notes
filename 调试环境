https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/  
环境ubuntu：
需要download 以前的qemu 版本，否者要死机，这在文档里面写到过
gdb 用这个 gdb-multiarch


cat /root/.gdbinit
file /root/xv6-labs-2020/kernel/kernel
target remote :25000
b walk

https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf
调试过程中重要的寄存器（查看页表）
i r all  //这个可以看到更多的寄存器
sepc           0x80005cb2       2147507378   //出现问题的那一行代码，可以用disassemble $sepc 来看是哪条语句
scause         0xf      15    //表示页表fault
stval          0x3eab84a3f0     269165569008  //这里放着被访问的虚拟地址，也就是访问这个地址导致的page fault

有时候串口不打印任何东西，很可能是串口输出地址页表没有映射或者损坏，这个时候gdb进去看看寄存器可以得到一些提示
i threads 看看那个线程大概出了问题

kvmcreate()
{
  pagetable_t pagetable;
  int i;

  pagetable = uvmcreate();
  /* for(i = 0; i < 512; i++) { */
  for(i = 1; i < 512; i++) {
    pagetable[i] = kernel_pagetable[i];
    /* pagetable[i] = 0; */
  }

vmprint(pagetable);
vmprint(kernel_pagetable);

  // uart registers
  /* kvmmapkern(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W); */   //比如注销这行意味着串口部分的地址没有进行映射，之后会出现page fault,但这时候串口已经无法打印了

(gdb) i threads
  Id   Target Id                    Frame
  1    Thread 1.1 (CPU#0 [running]) 0x0000000080005da4 in timervec ()
  2    Thread 1.2 (CPU#1 [running]) uartputc_sync (c=<optimized out>) at kernel/uart.c:121
* 3    Thread 1.3 (CPU#2 [running]) 0x0000000080005d80 in timervec ()

page fault的例子：
(gdb) p $scause
$11 = 13
(gdb) p/x $scause
$12 = 0xd
(gdb) p $sepc
$13 = 2147485718
(gdb) p/x $sepc
$14 = 0x80000816
(gdb) disassemble 0x80000816
Dump of assembler code for function uartputc_sync:

   0x0000000080000824 <+50>:    lui     a5,0x10000
   0x0000000080000828 <+54>:    sb      a0,0(a5) # 0x10000000  // 寄存器a4中地址加上5的位置的内容，将其放入寄存器a5中
   0x000000008000082c <+58>:    auipc   ra,0x0
   0x0000000080000830 <+62>:    jalr    1064(ra) # 0x80000c54 <pop_off>
   0x0000000080000834 <+66>:    ld      ra,24(sp)



